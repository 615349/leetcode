Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.

Return the intersection of these two interval lists.

(Formally, a closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)

Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

要考虑两个两个数组的交集比较困难，可以把两个数组合并为一个，按照从小到大的排序，
然后比较a[i-1][1] >= a[i][0]，如果是，那么就可以得到[a[i][0], Math.min(a[i][1], a[i-1][1])]

但是这么计算有一个问题，举个例子
[9, 20], [14, 15], [16, 21]
如果只是相邻之间比较，那么就只会得到[14,15]，但是实际上还有[16, 20]

看到这里就应该很清楚了。需要用一个变量记录到前一个index为止的max。然后用当前的a[i][0]和max进行比较。
如果小于max，则去a[i][0]到Math.min(max, arr[i][1])。

另外要注意edge case。如果a和b两个入参的长度都是0，那么直接返回。否则let max = arr[0][1];会报错


var intervalIntersection = function(A, B) {
    const arr = A.concat(B);
    
    const result = [];
    if (arr.length === 0) {
        return result;
    }
    
    arr.sort((a, b) => a[0] - b[0])
    
    let max = arr[0][1];
    
    for(let i = 1; i < arr.length; i++) {
        if (arr[i][0] <= max) {
            const min = Math.min(max, arr[i][1]);
            const temp = [arr[i][0], min];
            result.push(temp);
        }
        max = Math.max(max, arr[i][1]);
    }
    
    return result;
};
